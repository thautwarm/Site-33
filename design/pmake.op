@toc|--depth 1|

@begin ptag-set
    Topic(Idea)
    Topic(Python, BuildSystem)
    Time('2023-12-24')
    Language(Chinese)
@end ptag-set

@center-all| |

@begin md

# PMakefile：替换 CMake 和 GNU Make 的解决方案

@begin comment

解决问题：
1. 可复现、可移植的软件构建很困难
2. 旧的构建系统，很难适配新技术（如支持跨架构、跨平台编译的 zig cc/c++ 编译器）
3. Shell 语言家族处理复杂逻辑很困难，且难以调试；Shell 家族处理路径 escape 问题很困难
4. 静态检查和自动补全很困难

observation：
1. Python 3.7 无处不在（新时代的Python 2.7）
2. Python 处理路径 escape 可以确保正确性，路径处理与平台无关
3. Python 内置的字符串处理功能丰富，且没有学习曲线
4. Python 静态检查和自动补全很完善，受 PyCharm / VSCode Pylance (Type checking mode 设为 basic) 支持
@end comment


## 写在前面

在我第一次编写 Makefile 时，对它使用 TAB (`\t`) 来缩进的方式感到一种高山仰止般的倾佩。

## 背景

思考这么一个问题：当你正使用十年内出现的编译器或其他软件时，你所依赖的软件构建系统，其设计来自于哪个时代？

这个问题的答案可能会让你感到惊讶。在过去的几十年里，软件构建系统的设计几乎没有变化。这些系统的设计是在 20 世纪 70 年代和 80 年代完成的，当时的计算机软件所能依仗的工具非常有限，并且，人们评判软件易用性和复杂度的具体标准也与今日也不太相同。虽然随着时间推移，古老的构建系统在功能完整型上发生了重大的改进，比如 Makefile 构建很早就能并行。但他们设计的“基点”，仍然会在具体的事情里暴露他们与时代不协调的古老。

讲个故事，近期，我用了些业余时间捣鼓 QuickJS 和 Zig。

总的来说，我想做的事情是，支持 F# / TypeScript 的跨平台 Native 编译和极小体积部署。如果这个尝试成功，这样我们可以在任何平台上运行 F# / TypeScript 代码，且不需要 .NET / Node.js 环境，甚至支持导出 C 函数给其他语言调用。而 F# 和 TypeScript 这两门语言，可以覆盖绝大多数的编程场景。

这个想法听起来很简单，过程也很直接，但实际上，要实现这个想法，需要解决很多具体问题。其中一个问题，就是如何让我的构建系统具备一些跨平台、跨架构的能力。

首先出场的选手是 CMake，但我不是很精通它，将 C 编译器替换为 Zig CC/C++ 来适配任何能找到的 QuickJS 的构建文件，对我实在有点困难；随后登场的是 GNU Make，虽然成功完成了 QuickJS 的构建（这只是整个目标的第一小步），但这位老登在顺序命令执行、环境变量传递、路径转义和复杂字符串处理等方面的表现，让我有些哑口无言，另外补全和 IDE 检查真的很差。

CMake 对现代交叉编译工具似乎不那么友好，而编写 Makefile 的过程让人充满不安。

这两个构建系统设计上应是对 C/C++ 特攻，但实际上，它们不仅在 C/C++ 部分场景下不如人意，在其他语言上就更是不堪一击 —— 这种评价自然很主观，但其反应的问题是客观的：传统构建系统，真的不一定适应现代的开发。

此外，这些基于 SHELL 的构建工具还有很多其他问题：

1. 跨平台的路径处理很困难，需要考虑路径分隔符、路径转义等问题，因为我是一个MinGW用户，我甚至还要考虑 Windows/Unix 路径转换的问题
2. 字符串的处理大量使用了DSL，追求复杂度换简洁性的极致
3. SHELL 语言家族本身已经离主流工业语言比较远了，上一次见到这么远的还是MATLAB

虽然 CMake 和 GNU Make 仍然强大，但说到它们是否过时，可以拿以下几个问题来问自己：

1. 传统构建系统的底层技术，是否困难到需要创建专门的 DSL ？对我来说，NO。
2. 传统构建系统的学习曲线，是否比较陡峭？对我来说，Probably。
3. 在2的基础上，当我深入学习传统的构建系统后，相比我在学习前，是否获取了更多的构建工具功能？对我来说，NO，基本零增量；除开 CMake 检测依赖的丰富规则，没有值得称道的地方。
4. 相比于传统构建系统，如果使用新方案完成当前的构建目标（即 F# / TypeScript 的跨平台 Native 编译和极小体积部署），工作量是否增加？对我来说，NO；我无法维护超过1500行的 Makefile，将多个不以C/C++为主的构建工具集成到 GNU Make 中，会让我崩溃，实际上，我很需要 IDE 重命名功能来重构构建目标的名字和路径，这个是 CMake 和 GNU Make 都遥不可及的。

为了解决旧工具的不足，我捣鼓了一套新的解决方案：基于 Python 的类 Makefile 构建系统，即PMakefile。

PMakefile 是相对冗长的，相比于GNU Make 和 CMake，它**不承诺简洁**。

但 PMakefile 承诺以下这些我所关心的功能点：

1. 可移植性：在各个操作系统下，使用相同的构建脚本
2. 可复现性（针对小型软件）：可通过 PyPI 等平台无关的软件管理机制，快速获得正确一致的构建环境
3. 平台无关的路径处理：严格来说，它属于可移植性的一部分，但我认为它相当重要，路径处理问题在SHELL语言族中确实存在，而我不愿在无关的事情上浪费时间
4. 确定可靠、上下文无关的字符串转义处理：这实际上是SHELL语言族的问题，但 Python shlex 模块和 subprocess 模块很好地隔离了相关问题
5. 原生支持连续的命令，支持复用命令的输出，支持继承环境变量（虽然这一点是 Make 尝试解决的问题，但实践需要）
6. 强大的静态检查、自动补全和重构功能
7. 用户友好：轻量级、低延迟、安装简单

## 设计概述

PMakefile 的设计目标是，将构建脚本的编写，转化为 Python 脚本的编写。

结构上的设计灵感是，将构建目标的编写，转化为 Python 函数的编写，如下所示：

```python
from pmakefile import * # type: ignore

phony([
    'dep1',
    'dep2',
    'target1',
    ...
])

@recipe(...)
def dep1():
    ...

@recipe(...)
def dep2():
    ...

@recipe('dep1', 'dep2')
def target1():
    cmd1()
    cmd2()
```

这里可以看到，PMakefile 还是沿用了很多 Makefile 的概念，比如 phony target 和 构建依赖等。这是一个比较尴尬的事情，之所以沿袭旧的概念，并不是说这些概念一定是最有效的，只是因为目标项目的整体工程量比较小，我出于复用旧有知识、旧有经验的考虑，才选择了这种设计。

@end md