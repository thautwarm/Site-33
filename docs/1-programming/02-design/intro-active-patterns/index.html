<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>A Short Introduction to Active Patterns</title><meta name="supported-color-schemes" content="light dark"><meta name="theme-color" content="hsl(220, 20%, 100%)" media="(prefers-color-scheme: light)"><meta name="theme-color" content="hsl(220, 20%, 10%)" media="(prefers-color-scheme: dark)"><link rel="stylesheet" href="/Site-33/pagefind/pagefind-ui.css"><link rel="stylesheet" href="/Site-33/styles.css"><link rel="canonical" href="/Site-33/1-programming/02-design/intro-active-patterns/"><link rel="icon" sizes="48x48" href="/Site-33/favicon.ico">
<link rel="apple-touch-icon" sizes="180x180" href="/Site-33/apple-touch-icon.png">
<script type="text/javascript" src="/Site-33/pagefind/pagefind-ui.js"></script><script type="text/javascript">window.addEventListener('DOMContentLoaded',()=>{new PagefindUI({"element":"#search","showImages":false,"excerptLength":0,"showEmptyFilters":true,"showSubResults":false,"resetStyles":true,"bundlePath":"/Site-33/pagefind/","baseUrl":"/Site-33/"});});</script></head><body><div></div><div class="container"><div class="toolbar"><div id="search" class="search"></div></div><nav class="menu-container"><a class="menu-highlight" href="/Site-33/">Site-33 by thautwarm</a><ul class="menu"></ul></nav><main class="main"><nav><ul class="breadcrumb"><li class="breadcrumb-item"><a href="/Site-33/">Site-33 by thautwarm</a></li><li class="breadcrumb-item"><a href="/Site-33/1-programming/">Programming 编程</a></li><li class="breadcrumb-item"><a href="/Site-33/1-programming/02-design/">设计模式</a></li></ul></nav><div class="body" data-pagefind-body="true"><em> 此文档创建于 2022/1/26 </em><div><h1>A Short Introduction to Active Patterns</h1>
<p>The progress of adopting pattern matching in mainstream industrial programming languages is accelerating. Python and Ruby have already supported such an impressive feature, which leads to quite a different atmosphere in the world of programming languages.</p>
<p>However, their rejection of <strong>active patterns</strong> is disappointing. Active patterns, or view patterns, is a mechanism to pattern match data structure using custom, specific perspectives. For instance, the notation of list deconstruction is so convenient that it becomes a mark of functional programming languages. A list is partitioned into two parts, the first few elements and the tail of the list. The following OCaml/F# program shows how list deconstruction eases sequence processing.</p>

<div style="position: relative">
	<pre><code class="language-fsharp hljs"><span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> string_unescape (chars<span class="hljs-operator">:</span> <span class="hljs-type">list</span><span class="hljs-operator">&lt;</span><span class="hljs-type">char</span><span class="hljs-operator">&gt;</span>) <span class="hljs-operator">:</span> <span class="hljs-type">list</span><span class="hljs-operator">&lt;</span><span class="hljs-type">char</span><span class="hljs-operator">&gt;</span> <span class="hljs-operator">=</span>
    <span class="hljs-keyword">match</span> chars <span class="hljs-keyword">with</span>
    <span class="hljs-operator">|</span> <span class="hljs-string">'"'</span><span class="hljs-operator">::</span>[] <span class="hljs-operator">-&gt;</span> []
    <span class="hljs-operator">|</span> <span class="hljs-string">'"'</span><span class="hljs-operator">::</span>_ <span class="hljs-operator">-&gt;</span> <span class="hljs-comment">(* invalid string literal *)</span>
    <span class="hljs-operator">|</span> <span class="hljs-string">'\\'</span> <span class="hljs-operator">::</span> <span class="hljs-string">'"'</span> <span class="hljs-operator">::</span> tail <span class="hljs-operator">-&gt;</span> <span class="hljs-string">'"'</span> <span class="hljs-operator">::</span> string_unescape tail
    <span class="hljs-operator">|</span> <span class="hljs-string">'\\'</span> <span class="hljs-operator">::</span> <span class="hljs-string">'n'</span> <span class="hljs-operator">::</span> tail <span class="hljs-operator">-&gt;</span> <span class="hljs-string">'\n'</span> <span class="hljs-operator">::</span> string_unescape tail
    <span class="hljs-operator">|</span> <span class="hljs-operator">...</span>
</code></pre>

	<button class="code-copy-button" data-clipboard-text="let rec string_unescape (chars: list<char>) : list<char> =
    match chars with
    | '&quot;'::[] -> []
    | '&quot;'::_ -> (* invalid string literal *)
    | '\\' :: '&quot;' :: tail -> '&quot;' :: string_unescape tail
    | '\\' :: 'n' :: tail -> '\n' :: string_unescape tail
    | ...
">
        <span class="code-copy-icon"></span>
    </button>
</div>
<p>It is also observed that such convenient notation does not only work for lists. Arrays, which is not a recursive data structure, can also enjoy such convenience. Subarrays, or array views, which is a data structure constructed in <span><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span></span> time,  can be leveraged to support list-like array deconstruction, if active patterns are supported. List-like array deconstruction allows us to implement <code>string_unescape</code> that accepts an array.</p>

<div style="position: relative">
	<pre><code class="language-fsharp hljs"><span class="hljs-keyword">type</span> <span class="hljs-title class_">array_view</span><span class="hljs-operator">&lt;</span><span class="hljs-symbol">'a</span><span class="hljs-operator">&gt;</span> <span class="hljs-operator">=</span> { source<span class="hljs-operator">:</span> <span class="hljs-type">array</span><span class="hljs-operator">&lt;</span><span class="hljs-symbol">'a</span><span class="hljs-operator">&gt;</span>; offset<span class="hljs-operator">:</span> <span class="hljs-type">int</span> }

<span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> string_unescape (chars<span class="hljs-operator">:</span> array_view<span class="hljs-operator">&lt;</span><span class="hljs-type">char</span><span class="hljs-operator">&gt;</span>) <span class="hljs-operator">:</span> <span class="hljs-type">list</span><span class="hljs-operator">&lt;</span><span class="hljs-type">char</span><span class="hljs-operator">&gt;</span> <span class="hljs-operator">=</span>
    <span class="hljs-keyword">match</span> chars <span class="hljs-keyword">with</span>
    <span class="hljs-operator">|</span> ArrCons(<span class="hljs-string">'"'</span>, ArrNil) <span class="hljs-operator">-&gt;</span> []
    <span class="hljs-operator">|</span> ArrCons(<span class="hljs-string">'"'</span>, _) <span class="hljs-operator">-&gt;</span> <span class="hljs-comment">(* invalid string literal *)</span>
    <span class="hljs-operator">|</span> ArrCons(<span class="hljs-string">'\\'</span>, ArrCons(<span class="hljs-string">'"'</span>, tail)) <span class="hljs-operator">-&gt;</span> <span class="hljs-string">'"'</span> <span class="hljs-operator">::</span> string_unescape tail
    <span class="hljs-operator">|</span> ArrCons(<span class="hljs-string">'\\'</span>, ArrCons(<span class="hljs-string">'n'</span>, tail)) <span class="hljs-operator">-&gt;</span> <span class="hljs-string">'\n'</span> <span class="hljs-operator">::</span> string_unescape tail
    <span class="hljs-operator">|</span> <span class="hljs-operator">...</span>
</code></pre>

	<button class="code-copy-button" data-clipboard-text="type array_view<'a> = { source: array<'a>; offset: int }

let rec string_unescape (chars: array_view<char>) : list<char> =
    match chars with
    | ArrCons('&quot;', ArrNil) -> []
    | ArrCons('&quot;', _) -> (* invalid string literal *)
    | ArrCons('\\', ArrCons('&quot;', tail)) -> '&quot;' :: string_unescape tail
    | ArrCons('\\', ArrCons('n', tail)) -> '\n' :: string_unescape tail
    | ...
">
        <span class="code-copy-icon"></span>
    </button>
</div>
<p>As can be seen from the above code, we use 2 patterns <code>ArrCons</code> and <code>ArrNil</code>. These patterns are very similar to that in the list deconstruction. However, they do not indicate the shape of an <code>array_view&lt;'a&gt;</code>, instead, they deconstruct an <code>array_view&lt;'a&gt;</code> using a custom, specific perspective; they are active patterns.</p>
<p>Active patterns are supported in Haskell and F#. We can define patterns for an existing data type to fit our task-specific use. There is a valid F# implementation for the aforementioned <code>ArrCons</code> and <code>ArrNil</code>.</p>

<div style="position: relative">
	<pre><code class="language-fsharp hljs"><span class="hljs-keyword">let</span> (<span class="hljs-operator">|</span>ArrCons<span class="hljs-operator">|</span>ArrNil<span class="hljs-operator">|</span>) ({source <span class="hljs-operator">=</span> source; offset<span class="hljs-operator">=</span>offset}<span class="hljs-operator">:</span> array_view<span class="hljs-operator">&lt;</span><span class="hljs-symbol">'a</span><span class="hljs-operator">&gt;</span>) <span class="hljs-operator">=</span>
    <span class="hljs-keyword">if</span> offset <span class="hljs-operator">&gt;=</span> Array.length source
    <span class="hljs-keyword">then</span> ArrNil
    <span class="hljs-keyword">else</span> ArrCons(source.[offset], {source<span class="hljs-operator">=</span>source; offset<span class="hljs-operator">=</span>offset <span class="hljs-operator">+</span> <span class="hljs-number">1</span>})
</code></pre>

	<button class="code-copy-button" data-clipboard-text="let (|ArrCons|ArrNil|) ({source = source; offset=offset}: array_view<'a>) =
    if offset >= Array.length source
    then ArrNil
    else ArrCons(source.[offset], {source=source; offset=offset + 1})
">
        <span class="code-copy-icon"></span>
    </button>
</div>
<p>Active patterns allow customizable pattern matching, considerably improving the readability. However, this might not be the truth for people who see it the first time. To make it easier for newcomers to read, we give a program equivalent to the above, to clarify the behaviour of active patterns.</p>

<div style="position: relative">
	<pre><code class="language-fsharp hljs"><span class="hljs-keyword">type</span> <span class="hljs-title class_">array_decons</span> <span class="hljs-operator">=</span>
    <span class="hljs-operator">|</span> ArrCons <span class="hljs-keyword">of</span> <span class="hljs-symbol">'a</span> <span class="hljs-operator">*</span> array_view<span class="hljs-operator">&lt;</span><span class="hljs-symbol">'a</span><span class="hljs-operator">&gt;</span>
    <span class="hljs-operator">|</span> ArrNil

<span class="hljs-keyword">let</span> array_decons<span class="hljs-operator">:</span> array_view<span class="hljs-operator">&lt;</span><span class="hljs-symbol">'a</span><span class="hljs-operator">&gt;</span> <span class="hljs-operator">-&gt;</span> array_decons <span class="hljs-operator">=</span> <span class="hljs-keyword">fun</span> <span class="hljs-operator">-&gt;</span>
    <span class="hljs-keyword">if</span> offset <span class="hljs-operator">&gt;=</span> Array.length source
    <span class="hljs-keyword">then</span> ArrNil
    <span class="hljs-keyword">else</span> ArrCons(source.[offset], {source<span class="hljs-operator">=</span>source; offset<span class="hljs-operator">=</span>offset <span class="hljs-operator">+</span> <span class="hljs-number">1</span>})


<span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> string_unescape (chars<span class="hljs-operator">:</span> array_view<span class="hljs-operator">&lt;</span><span class="hljs-type">char</span><span class="hljs-operator">&gt;</span>) <span class="hljs-operator">:</span> <span class="hljs-type">list</span><span class="hljs-operator">&lt;</span><span class="hljs-type">char</span><span class="hljs-operator">&gt;</span> <span class="hljs-operator">=</span>
    <span class="hljs-keyword">match</span> array_decons chars <span class="hljs-keyword">with</span>
    <span class="hljs-operator">|</span> ArrCons(<span class="hljs-string">'"'</span>, ArrNil) <span class="hljs-operator">-&gt;</span> []
    <span class="hljs-operator">|</span> <span class="hljs-operator">...</span>
</code></pre>

	<button class="code-copy-button" data-clipboard-text="type array_decons =
    | ArrCons of 'a * array_view<'a>
    | ArrNil

let array_decons: array_view<'a> -> array_decons = fun ->
    if offset >= Array.length source
    then ArrNil
    else ArrCons(source.[offset], {source=source; offset=offset + 1})


let rec string_unescape (chars: array_view<char>) : list<char> =
    match array_decons chars with
    | ArrCons('&quot;', ArrNil) -> []
    | ...
">
        <span class="code-copy-icon"></span>
    </button>
</div>
<p>Such code unveils that using active patterns is no more than applying a transformation to match targets. A naive implementation of active patterns is suggested as well.</p>

<div style="position: relative">
	<pre><code class="language-fsharp hljs"><span class="hljs-keyword">let</span> (<span class="hljs-operator">|</span>Positive<span class="hljs-operator">|</span>NotPositive<span class="hljs-operator">|</span>) x <span class="hljs-operator">=</span> <span class="hljs-keyword">if</span> x <span class="hljs-operator">&gt;</span>  <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> Positive <span class="hljs-keyword">else</span> NotPositive
<span class="hljs-keyword">let</span> (<span class="hljs-operator">|</span>Zero<span class="hljs-operator">|</span>NotZero<span class="hljs-operator">|</span>) x <span class="hljs-operator">=</span> <span class="hljs-keyword">if</span> x <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> Zero <span class="hljs-keyword">else</span> NotZero

<span class="hljs-keyword">match</span> <span class="hljs-number">0</span> <span class="hljs-keyword">with</span>
<span class="hljs-operator">|</span> <span class="hljs-number">10</span> <span class="hljs-operator">-&gt;</span> <span class="hljs-number">0</span>       <span class="hljs-comment">(* natural pattern of int *)</span>
<span class="hljs-operator">|</span> Positive <span class="hljs-operator">-&gt;</span> <span class="hljs-number">1</span> <span class="hljs-comment">(* patterns: Positive/NotPositive *)</span>
<span class="hljs-operator">|</span> NotZero <span class="hljs-operator">-&gt;</span> <span class="hljs-number">2</span>  <span class="hljs-comment">(* patterns: Zero/NotZero *)</span>
<span class="hljs-operator">|</span> _ <span class="hljs-operator">-&gt;</span> <span class="hljs-number">3</span>
<span class="hljs-comment">// =&gt; 3</span>
</code></pre>

	<button class="code-copy-button" data-clipboard-text="let (|Positive|NotPositive|) x = if x >  0 then Positive else NotPositive
let (|Zero|NotZero|) x = if x = 0 then Zero else NotZero

match 0 with
| 10 -> 0       (* natural pattern of int *)
| Positive -> 1 (* patterns: Positive/NotPositive *)
| NotZero -> 2  (* patterns: Zero/NotZero *)
| _ -> 3
// => 3
">
        <span class="code-copy-icon"></span>
    </button>
</div>
<p>However, in practice, the implementation of active patterns can avoid redundant allocations (by laziness or analysis). Different active patterns defined for the same data type can be used simultaneously, which makes active patterns a good approach to non-invasive extensions to pattern matching.</p>
</div></div></main></div><script src="/Site-33/js/clipboard.js"></script></body></html>